<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Chat — Classy & Relaxed (Updated)</title>
<style>
  :root{
    --bg: #f6f7f9; --panel:#ffffff; --muted:#6b7280; --text:#111827; --accent:#2563eb;
    --user-bg:#e6f0ff; --assistant-bg:#fff;
    --card-radius:14px; --glass: rgba(255,255,255,0.6);
    --sidebar-w:340px; --sidebar-collapsed-w:56px;
  }
  [data-theme="dark"]{
    --bg: #0b1020; --panel:#0f1724; --muted:#9aa4b2; --text:#e6eef6; --accent:#60a5fa;
    --user-bg:#13304b; --assistant-bg:#0b1220; --glass: rgba(255,255,255,0.02);
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  body{
    background: linear-gradient(180deg,var(--bg), rgba(0,0,0,0));
    color:var(--text); padding:12px;
    transition: background .18s, color .18s;
  }

  /* Layout */
  .app{
    max-width:1200px; margin:0 auto; height:calc(100vh - 24px);
    display:grid; grid-template-columns: 1fr var(--sidebar-w); gap:18px;
  }
  .app.collapsed{ grid-template-columns: 1fr var(--sidebar-collapsed-w); }
  @media (max-width:920px){ .app{grid-template-columns:1fr; height:auto} .sidebar{order:2} }

  /* Main panel */
  .panel{
    background:linear-gradient(180deg,var(--panel),var(--glass));
    border-radius: var(--card-radius); padding:14px; min-height:0;
    box-shadow: 0 6px 24px rgba(2,6,23,0.12);
    display:flex; flex-direction:column; height:100%;
  }
  .header{display:flex;align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px}
  .title{font-weight:600; font-size:18px}
  .controls{display:flex; gap:8px; align-items:center}

  /* Chat area full height */
  .chat-wrap{flex:1; display:flex; flex-direction:column; min-height:0}
  .chat{flex:1; overflow:auto; padding:8px; display:flex; flex-direction:column; gap:10px; scroll-behavior:smooth}
  .msg{max-width:82%; padding:12px; border-radius:12px; position:relative; white-space:pre-wrap; word-break:break-word;}
  .msg .meta{font-size:12px; color:var(--muted); margin-bottom:6px}
  .msg.user{align-self:flex-end; background:linear-gradient(180deg,var(--user-bg), rgba(0,0,0,0.02)); color:var(--text)}
  .msg.assistant{align-self:flex-start; background:linear-gradient(180deg,var(--assistant-bg), rgba(0,0,0,0.02)); color:var(--text)}
  .msg .actions{position:absolute; top:6px; right:8px; display:flex; gap:6px}
  .btn{background:transparent;border:none;padding:6px 8px;border-radius:8px;cursor:pointer;color:var(--muted)}
  .btn:hover{color:var(--text); background:rgba(0,0,0,0.04)}
  .input-row{display:flex; gap:8px; margin-top:12px; align-items:center}
  .input-row textarea{flex:1; min-height:56px; max-height:260px; padding:12px; border-radius:10px; border:1px solid rgba(0,0,0,0.06); resize:vertical; background:transparent; color:var(--text)}
  .send{background:var(--accent); color:white; border:none; padding:10px 14px; border-radius:10px; cursor:pointer}
  .muted{color:var(--muted); font-size:13px}

  /* Sidebar/settings */
  .sidebar{height:100%; overflow:auto; transition: width .18s; display:flex; flex-direction:column; gap:12px}
  .app.collapsed .sidebar{ width:var(--sidebar-collapsed-w); min-width:var(--sidebar-collapsed-w); }
  .card{background:linear-gradient(180deg,var(--panel),var(--glass)); padding:12px; border-radius:12px; box-shadow:0 6px 18px rgba(2,6,23,0.08)}
  .setting-group{margin-bottom:12px}
  label{display:block; font-size:13px; color:var(--muted); margin-bottom:6px}
  input[type=text], input[type=url], input[type=number], select, textarea, input[type=password]{
    width:100%; padding:8px 10px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:transparent; color:var(--text)
  }
  .small{font-size:13px; color:var(--muted)}
  .row{display:flex; gap:8px}
  .col{flex:1}

  /* Toggles & sliders */
  .toggle{display:inline-flex; align-items:center; gap:8px; cursor:pointer; user-select:none}
  .switch{width:44px; height:26px; background:rgba(0,0,0,0.08); border-radius:999px; position:relative; display:inline-block}
  .switch .knob{width:20px;height:20px;background:white;border-radius:50%;position:absolute;top:3px;left:3px;transition:all .18s}
  .switch.on{background:var(--accent)}
  .switch.on .knob{left:21px}

  /* streaming indicator */
  .spinner{width:16px;height:16px;border-radius:50%; border:2px solid rgba(255,255,255,0.15); border-top-color:var(--accent); animation:spin 1s linear infinite; display:inline-block}
  @keyframes spin{to{transform:rotate(360deg)}}

  /* message editor */
  .editor{margin-top:8px; display:flex; gap:8px}
  .editor textarea{flex:1; min-height:78px}

  /* minimal tooltips */
  .hint{border-bottom:1px dotted var(--muted); cursor:help; padding:0 6px; border-radius:4px; line-height:1}

  /* footer */
  .footer{display:flex; justify-content:space-between; align-items:center; margin-top:10px; font-size:13px; color:var(--muted)}
  .error{background:rgba(220,38,38,0.08); color:#fff;padding:8px;border-radius:8px;font-size:13px}
  .ok{background:rgba(34,197,94,0.08); color:#fff;padding:8px;border-radius:8px;font-size:13px}
  .collapse{cursor:pointer;color:var(--muted); font-size:13px}
  .small-btn{background:transparent;border:1px solid rgba(0,0,0,0.06); padding:6px 8px;border-radius:8px; cursor:pointer}
  .note{font-size:12px;color:var(--muted);margin-top:6px}

  /* collapsed sidebar styles (icons only) */
  .sidebar .compact{
    display:none; flex-direction:column; gap:8px; align-items:center; padding:8px;
  }
  .app.collapsed .sidebar .settings-main{display:none}
  .app.collapsed .sidebar .compact{display:flex}
  .compact .icon-btn{width:40px;height:40px;border-radius:8px;display:flex;align-items:center;justify-content:center;border:1px solid rgba(0,0,0,0.06); cursor:pointer}
  .compact .icon-btn svg{width:20px;height:20px; fill:var(--muted)}
  .app.collapsed .sidebar{padding-top:8px}

  /* responsive small screens: make sidebar slide in/out */
  @media (max-width:920px){
    .app{grid-template-columns:1fr; height:auto}
    .sidebar{position:relative}
  }
</style>
</head>
<body data-theme="light">
<div class="app" id="app">
  <main class="panel">
    <div class="header">
      <div>
        <div class="title">AI Chat</div>
        <div class="muted" id="subtitle">Classy · Relaxed · Local keys</div>
      </div>
      <div class="controls" role="toolbar" aria-label="Main controls">
        <div class="toggle" id="themeToggle" title="Toggle theme" tabindex="0" role="button" aria-pressed="false">
          <div id="themeSwitch" class="switch" aria-hidden="true"><div class="knob"></div></div>
          <div id="themeLabel" class="muted">Light</div>
        </div>
        <button class="small-btn" id="clearAll">Clear Chat</button>
        <button class="small-btn" id="focusSettings">Settings</button>
      </div>
    </div>

    <div class="chat-wrap">
      <div class="chat" id="chat" aria-live="polite" aria-atomic="false"></div>

      <div class="input-row">
        <textarea id="userInput" placeholder="Type a message... (Ctrl/Cmd+Enter to send)"></textarea>
        <button class="send" id="sendBtn">Send</button>
      </div>

      <div class="footer">
        <div class="muted" id="status">No streaming</div>
        <div class="muted">Session saved locally</div>
      </div>
    </div>
  </main>

  <aside class="sidebar" id="sidebar">
    <!-- compact (collapsed) view -->
    <div class="compact" aria-hidden="true">
      <div class="icon-btn" id="expandSidebar" title="Open settings">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a2 2 0 012 2v1.07a6.002 6.002 0 013.9 3.9H19a2 2 0 110 4h-.1a6.002 6.002 0 01-3.9 3.9V20a2 2 0 11-4 0v-1.07a6.002 6.002 0 01-3.9-3.9H5a2 2 0 110-4h1.07a6.002 6.002 0 013.9-3.9V4a2 2 0 012-2z"/></svg>
      </div>
      <div class="icon-btn" id="toggleThemeCompact" title="Toggle theme compact">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"/></svg>
      </div>
    </div>

    <!-- main settings panel -->
    <div class="settings-main card" id="settingsCard" role="region" aria-label="Settings">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <strong>Settings</strong>
        <div style="display:flex;gap:8px;align-items:center">
          <button class="small-btn" id="collapseSidebarBtn" title="Collapse to side">⇨</button>
        </div>
      </div>

      <div id="settingsInner">
        <div class="setting-group">
          <label>Provider</label>
          <select id="providerSelect">
            <option value="openai">OpenAI (API)</option>
            <option value="openrouter">OpenRouter</option>
            <option value="mistral">Mistral</option>
            <option value="aistudio">AI Studio</option>
            <option value="custom">Custom (OpenAI-compatible)</option>
          </select>
        </div>

        <div class="setting-group" id="endpointGroup" style="display:none">
          <label>Custom endpoint <span class="small muted">(full URL)</span></label>
          <input type="url" id="customEndpoint" placeholder="https://api.example.com/v1/chat/completions" />
        </div>

        <div class="setting-group">
          <label>Model</label>
          <div class="row">
            <select id="modelSelect"></select>
            <input type="text" id="customModel" placeholder="Custom model name" />
          </div>
          <div class="note">Pick from the list or type a custom model name. System prompt and params apply to requests.</div>
        </div>

        <div class="setting-group">
          <label>System prompt</label>
          <textarea id="systemPrompt" placeholder="You are a helpful assistant..."></textarea>
          <div class="note">This prompt is prepended to every request. Persists across session.</div>
        </div>

        <div class="setting-group">
          <label>Generation parameters</label>
          <div style="display:grid;gap:8px">
            <div class="row">
              <div class="col">
                <label>Temperature <span class="hint" title="How creative/varied responses are (0-2).">?</span></label>
                <input type="number" id="temperature" step="0.1" min="0" max="2" />
              </div>
              <div class="col">
                <label>Top-p <span class="hint" title="Nucleus sampling: alternative to top-k; 0-1.">?</span></label>
                <input type="number" id="top_p" step="0.01" min="0" max="1" />
              </div>
            </div>

            <div class="row">
              <div class="col">
                <label>Top-k <span class="hint" title="Limits to the top K tokens considered.">?</span></label>
                <input type="number" id="top_k" step="1" min="0" />
              </div>
              <div class="col">
                <label>Max tokens <span class="hint" title="Maximum tokens in the assistant's response.">?</span></label>
                <input type="number" id="max_tokens" step="1" min="1" />
              </div>
            </div>

            <div class="row">
              <div style="flex:1">
                <label>Streaming</label>
                <div class="toggle" id="streamToggle" title="Enable streaming where provider supports it">
                  <div id="streamSwitch" class="switch" aria-hidden="true"><div class="knob"></div></div>
                  <div id="streamLabel" class="muted">Off</div>
                </div>
              </div>
              <div style="flex:1">
                <label>Show streaming partials</label>
                <div class="toggle" id="showPartialToggle">
                  <div id="partialSwitch" class="switch" aria-hidden="true"><div class="knob"></div></div>
                  <div id="partialLabel" class="muted">On</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="setting-group">
          <label>API Key (stored in browser only)</label>
          <select id="keyProviderSelect" style="margin-bottom:8px">
            <option value="openai">OpenAI</option>
            <option value="openrouter">OpenRouter</option>
            <option value="mistral">Mistral</option>
            <option value="aistudio">AI Studio</option>
            <option value="custom">Custom</option>
          </select>
          <div class="row">
            <input type="password" id="apiKeyInput" placeholder="Paste API key here" />
            <button class="small-btn" id="saveKeyBtn">Save</button>
          </div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button class="small-btn" id="showKeysBtn">Show Stored Keys</button>
            <button class="small-btn" id="clearKeysBtn">Clear Stored Keys</button>
          </div>
          <div id="keyList" class="note" style="margin-top:8px; display:none; white-space:pre-wrap;"></div>
        </div>

        <div class="setting-group">
          <label>Advanced</label>
          <div style="display:flex;gap:8px">
            <button class="small-btn" id="exportChat">Export JSON</button>
            <button class="small-btn" id="importChat">Import JSON</button>
          </div>
          <input type="file" id="importFile" accept="application/json" style="display:none" />
          <div class="note">Chats and settings are stored locally. Keys never leave your browser except to the provider when you send a request.</div>
        </div>
      </div>

    </div>
  </aside>
</div>

<script>
/* Local storage keys */
const LS_KEYS = { state: 'aichat_state_v1', keys: 'aichat_api_keys_v1', settings: 'aichat_settings_v1' };

/* Defaults */
const DEFAULT = {
  settings: {
    theme: 'light', provider: 'openai', customEndpoint: '', model: 'gpt-4o-mini', customModel: '',
    temperature: 0.7, top_p: 0.95, top_k: 0, max_tokens: 512, streaming: false, show_partials: true,
    system_prompt: 'You are a concise, helpful assistant.', collapsedSidebar: false
  },
  messages: []
};

/* Utilities */
const $ = s => document.querySelector(s);
const escapeHtml = s => s.replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[c]);
const uid = ()=> Math.random().toString(36).slice(2,9);
const nowISO = ()=> new Date().toISOString();

/* Provider layer (same shapes, keep simple) */
const Providers = {
  openai: {/* ... same as before, but simplified for brevity below (kept full in final) */},
  openrouter: {},
  mistral: {},
  aistudio: {}
};
/* We'll reuse the previous provider implementations (OpenAI-compatible streaming/parsing). */
/* For readability and to avoid missing functionality in this single-file, reinsert the same provider implementations exactly as before: */
(function defineProviders(){
  Providers.openai = {
    defaultEndpoint: 'https://api.openai.com/v1/chat/completions',
    sendChat: async (opts) => {
      const url = opts.endpoint || Providers.openai.defaultEndpoint;
      const headers = {'Content-Type':'application/json','Authorization': 'Bearer ' + opts.apiKey};
      const body = {model: opts.model, messages: opts.messages, max_tokens: opts.params.max_tokens, temperature: opts.params.temperature, top_p: opts.params.top_p, n:1};
      if (opts.params.top_k) body['top_k'] = opts.params.top_k;
      if (opts.streaming) body.stream = true;
      const res = await fetch(url, {method:'POST', headers, body: JSON.stringify(body), signal: opts.signal});
      if (!res.ok) {
        const txt = await res.text().catch(()=>null);
        throw {status:res.status, error: txt || res.statusText};
      }
      if (!opts.streaming) {
        const j = await res.json();
        const content = j?.choices?.[0]?.message?.content ?? j?.choices?.[0]?.text ?? JSON.stringify(j);
        return content;
      } else {
        const reader = res.body.getReader(); const dec = new TextDecoder(); let buf = '';
        while(true){
          const {done,value} = await reader.read();
          if (done) break;
          buf += dec.decode(value, {stream:true});
          let lines = buf.split(/\r?\n/); buf = lines.pop();
          for (let l of lines){
            l = l.trim(); if (!l) continue;
            if (l === 'data: [DONE]') { opts.onDelta('', true); return; }
            if (l.startsWith('data:')) {
              const payload = l.replace(/^data:\s*/, '');
              try {
                const parsed = JSON.parse(payload);
                const delta = parsed?.choices?.[0]?.delta?.content ?? parsed?.choices?.[0]?.text ?? '';
                if (delta) opts.onDelta(delta, false);
              } catch(e) {}
            }
          }
        }
        opts.onDelta('', true);
        return;
      }
    }
  };

  Providers.openrouter = {
    defaultEndpoint: 'https://api.openrouter.ai/v1/chat/completions',
    sendChat: Providers.openai.sendChat // reuse same parsing semantics (OpenRouter compatible)
  };

  Providers.mistral = {
    defaultEndpoint: 'https://api.mistral.ai/v1/generate',
    sendChat: Providers.openai.sendChat // allow custom endpoint; attempt OpenAI-compatible shape
  };

  Providers.aistudio = {
    defaultEndpoint: 'https://api.aistudio.example/v1/chat/completions',
    sendChat: Providers.openai.sendChat
  };
})();

/* State */
let state = loadState();
let apiKeys = loadKeys();
let settings = loadSettings();

/* Load/Save */
function loadState(){ try{const s=localStorage.getItem(LS_KEYS.state); return s?JSON.parse(s):{messages:DEFAULT.messages};}catch(e){return {messages:DEFAULT.messages}} }
function saveState(){ localStorage.setItem(LS_KEYS.state, JSON.stringify({messages: state.messages})); }
function loadKeys(){ try{const s=localStorage.getItem(LS_KEYS.keys); return s?JSON.parse(s):{} }catch(e){return {}} }
function saveKeys(){ localStorage.setItem(LS_KEYS.keys, JSON.stringify(apiKeys)); }
function loadSettings(){ try{const s=localStorage.getItem(LS_KEYS.settings); return s?JSON.parse(s):DEFAULT.settings;}catch(e){return DEFAULT.settings} }
function saveSettings(){ localStorage.setItem(LS_KEYS.settings, JSON.stringify(settings)); }

/* UI refs */
const appEl = $('#app');
const chatEl = $('#chat');
const userInput = $('#userInput');
const sendBtn = $('#sendBtn');
const clearAllBtn = $('#clearAll');
const focusSettingsBtn = $('#focusSettings');
const themeToggle = $('#themeToggle'), themeSwitch = $('#themeSwitch'), themeLabel = $('#themeLabel');
const providerSelect = $('#providerSelect'), endpointGroup = $('#endpointGroup'), customEndpoint = $('#customEndpoint');
const modelSelect = $('#modelSelect'), customModel = $('#customModel'), systemPrompt = $('#systemPrompt');
const temperature = $('#temperature'), top_p = $('#top_p'), top_k = $('#top_k'), max_tokens = $('#max_tokens');
const streamToggle = $('#streamToggle'), streamSwitch = $('#streamSwitch'), streamLabel = $('#streamLabel');
const showPartialToggle = $('#showPartialToggle'), partialSwitch = $('#partialSwitch'), partialLabel = $('#partialLabel');
const statusEl = $('#status');
const saveKeyBtn = $('#saveKeyBtn'), apiKeyInput = $('#apiKeyInput'), keyProviderSelect = $('#keyProviderSelect');
const showKeysBtn = $('#showKeysBtn'), clearKeysBtn = $('#clearKeysBtn'), keyListEl = $('#keyList');
const exportChatBtn = $('#exportChat'), importChatBtn = $('#importChat'), importFileInput = $('#importFile');
const collapseSidebarBtn = $('#collapseSidebarBtn'), expandSidebar = $('#expandSidebar'), compactThemeBtn = $('#toggleThemeCompact');

/* Init */
function init(){
  settings = Object.assign({}, DEFAULT.settings, settings || {});
  apiKeys = apiKeys || {};
  state = state || {messages: DEFAULT.messages};
  applySettingsToUI();
  renderModelOptions();
  bindEvents();
  bootstrapChat();
}
init();

/* Bind events */
function bindEvents(){
  sendBtn.addEventListener('click', onSend);
  userInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) onSend(); });

  clearAllBtn.addEventListener('click', ()=>{ if(confirm('Clear conversation?')){ state.messages=[]; saveState(); renderChat(); } });
  focusSettingsBtn.addEventListener('click', ()=>{ document.getElementById('settingsCard').scrollIntoView({behavior:'smooth'}); });

  // theme toggles (header and compact)
  themeToggle.addEventListener('click', toggleTheme);
  compactThemeBtn && compactThemeBtn.addEventListener && compactThemeBtn.addEventListener('click', toggleTheme);

  // sidebar collapse
  collapseSidebarBtn.addEventListener('click', ()=>{ settings.collapsedSidebar = true; applySidebarState(); saveSettings(); });
  expandSidebar && expandSidebar.addEventListener && expandSidebar.addEventListener('click', ()=>{ settings.collapsedSidebar = false; applySidebarState(); saveSettings(); });

  providerSelect.addEventListener('change', ()=>{ settings.provider = providerSelect.value; endpointGroup.style.display = (settings.provider==='custom')?'block':'none'; renderModelOptions(); saveSettings(); });
  customEndpoint.addEventListener('input', ()=>{ settings.customEndpoint = customEndpoint.value; saveSettings(); });
  modelSelect.addEventListener('change', ()=>{ settings.model = modelSelect.value; saveSettings(); });
  customModel.addEventListener('input', ()=>{ settings.customModel = customModel.value; saveSettings(); });
  systemPrompt.addEventListener('input', ()=>{ settings.system_prompt = systemPrompt.value; saveSettings(); });

  temperature.addEventListener('input', ()=>{ settings.temperature = Number(temperature.value); saveSettings(); });
  top_p.addEventListener('input', ()=>{ settings.top_p = Number(top_p.value); saveSettings(); });
  top_k.addEventListener('input', ()=>{ settings.top_k = Number(top_k.value); saveSettings(); });
  max_tokens.addEventListener('input', ()=>{ settings.max_tokens = Number(max_tokens.value); saveSettings(); });

  // streaming toggles: clicking either the container or the switch should work
  streamToggle.addEventListener('click', ()=>{ setSwitchState(streamSwitch, !streamSwitch.classList.contains('on'), streamLabel, 'On', 'Off', 'streaming'); });
  streamSwitch.addEventListener('click', (e)=>{ e.stopPropagation(); setSwitchState(streamSwitch, !streamSwitch.classList.contains('on'), streamLabel, 'On', 'Off', 'streaming'); });
  showPartialToggle.addEventListener('click', ()=>{ setSwitchState(partialSwitch, !partialSwitch.classList.contains('on'), partialLabel, 'On', 'Off', 'show_partials'); });
  partialSwitch.addEventListener('click', (e)=>{ e.stopPropagation(); setSwitchState(partialSwitch, !partialSwitch.classList.contains('on'), partialLabel, 'On', 'Off', 'show_partials'); });

  // API keys
  saveKeyBtn.addEventListener('click', saveApiKey);
  showKeysBtn.addEventListener('click', showStoredKeys);
  clearKeysBtn.addEventListener('click', ()=>{ if(confirm('Clear all stored API keys?')){ apiKeys = {}; saveKeys(); showStoredKeys(); } });
  keyProviderSelect.addEventListener('change', ()=>{ apiKeyInput.placeholder = 'Key for ' + keyProviderSelect.value; });

  exportChatBtn.addEventListener('click', ()=>{ const blob = new Blob([JSON.stringify({settings, messages: state.messages},null,2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='ai-chat-export.json'; a.click(); URL.revokeObjectURL(url); });
  importChatBtn.addEventListener('click', ()=>importFileInput.click());
  importFileInput.addEventListener('change', handleImportFile);
}

/* Helper to set switch state and persist */
function setSwitchState(el, on, labelEl, onText='On', offText='Off', settingKey){
  el.classList.toggle('on', !!on);
  if (labelEl) labelEl.textContent = on ? onText : offText;
  if (settingKey) {
    settings[settingKey] = !!on;
    saveSettings();
  }
  updateStatus();
}

/* Apply settings to UI */
function applySettingsToUI(){
  providerSelect.value = settings.provider || DEFAULT.settings.provider;
  endpointGroup.style.display = (settings.provider==='custom')?'block':'none';
  customEndpoint.value = settings.customEndpoint || '';
  systemPrompt.value = settings.system_prompt || DEFAULT.settings.system_prompt;
  temperature.value = settings.temperature ?? DEFAULT.settings.temperature;
  top_p.value = settings.top_p ?? DEFAULT.settings.top_p;
  top_k.value = settings.top_k ?? DEFAULT.settings.top_k;
  max_tokens.value = settings.max_tokens ?? DEFAULT.settings.max_tokens;

  streamSwitch.classList.toggle('on', !!settings.streaming); streamLabel.textContent = settings.streaming ? 'On' : 'Off';
  partialSwitch.classList.toggle('on', !!settings.show_partials); partialLabel.textContent = settings.show_partials ? 'On' : 'Off';

  settings.theme = settings.theme || DEFAULT.settings.theme;
  applyThemeUI(settings.theme);

  settings.collapsedSidebar = !!settings.collapsedSidebar;
  applySidebarState();
}

/* Theme functions */
function toggleTheme(){ settings.theme = (settings.theme === 'dark') ? 'light' : 'dark'; applyThemeUI(settings.theme); saveSettings(); }
function applyThemeUI(theme){
  document.body.setAttribute('data-theme', theme === 'dark' ? 'dark' : 'light');
  themeSwitch.classList.toggle('on', theme === 'dark');
  themeLabel.textContent = theme === 'dark' ? 'Dark' : 'Light';
}

/* Sidebar collapse */
function applySidebarState(){
  if (settings.collapsedSidebar) {
    appEl.classList.add('collapsed');
  } else {
    appEl.classList.remove('collapsed');
  }
}

/* Model options */
const MODEL_PRESETS = {
  openai: ['gpt-4o-mini', 'gpt-4o', 'gpt-4', 'gpt-3.5-turbo'],
  openrouter: ['chatopenai/gpt-4o-mini','chatopenai/gpt-4o','gpt-3.5-turbo'],
  mistral: ['mistral-medium', 'mistral-large'],
  aistudio: ['aistudio/fast', 'aistudio/standard'],
  custom: ['(enter custom model or select below)']
};
function renderModelOptions(){
  const prov = settings.provider || providerSelect.value || 'openai';
  modelSelect.innerHTML = '';
  (MODEL_PRESETS[prov] || MODEL_PRESETS['custom']).forEach(m=>{
    const opt = document.createElement('option'); opt.value = m; opt.textContent = m; modelSelect.appendChild(opt);
  });
  if (settings.model) modelSelect.value = settings.model;
}

/* API keys functions */
function saveApiKey(){
  const p = keyProviderSelect.value;
  const k = apiKeyInput.value.trim();
  if (!k){ alert('Enter a key to save'); return; }
  apiKeys[p] = k;
  saveKeys();
  apiKeyInput.value = '';
  alert('Saved key locally for ' + p);
}
function showStoredKeys(){
  keyListEl.style.display = Object.keys(apiKeys).length ? 'block' : 'none';
  keyListEl.textContent = Object.keys(apiKeys).length ? Object.keys(apiKeys).map(k => `${k}: ${apiKeys[k].slice(0,6)}…`).join('\n') : 'No keys saved';
}

/* Chat rendering */
function renderChat(){
  chatEl.innerHTML = '';
  for (let i=0;i<state.messages.length;i++){
    const m = state.messages[i];
    const div = document.createElement('div'); div.className = 'msg ' + (m.role==='user' ? 'user' : 'assistant');
    const meta = document.createElement('div'); meta.className='meta';
    meta.textContent = `${m.role === 'user' ? 'You' : 'Assistant'} · ${new Date(m.ts||'').toLocaleString() || ''}`;
    div.appendChild(meta);

    const act = document.createElement('div'); act.className='actions';
    const editBtn = document.createElement('button'); editBtn.className='btn'; editBtn.title='Edit message'; editBtn.innerText='Edit';
    editBtn.addEventListener('click', ()=>openEditor(m.id));
    const resendBtn = document.createElement('button'); resendBtn.className='btn'; resendBtn.title='Resend/Regenerate'; resendBtn.innerText = m.role==='user' ? 'Resend' : 'Regenerate';
    resendBtn.addEventListener('click', ()=>resendMessage(m.id));
    act.appendChild(editBtn); act.appendChild(resendBtn);
    div.appendChild(act);

    const content = document.createElement('div'); content.className='content';
    renderMessageContent(m.content, content);
    div.appendChild(content);

    if (m.error) {
      const err = document.createElement('div'); err.className='error'; err.textContent = 'Error: ' + m.error;
      div.appendChild(err);
    }

    chatEl.appendChild(div);
  }
  chatEl.scrollTop = chatEl.scrollHeight;
}

/* Safe rendering (preserve code blocks) */
function renderMessageContent(text, container){
  container.innerHTML = '';
  if (typeof text === 'undefined' || text === null) text = '';
  const parts = String(text).split(/```/g);
  for (let i=0;i<parts.length;i++){
    const p = parts[i];
    if (i%2 === 0){
      const div = document.createElement('div'); div.textContent = p; container.appendChild(div);
    } else {
      const pre = document.createElement('pre'); pre.style.background = 'rgba(0,0,0,0.04)'; pre.style.padding = '8px'; pre.style.borderRadius = '8px'; pre.style.overflowX = 'auto'; pre.textContent = p; container.appendChild(pre);
    }
  }
}

/* Editor & resend */
function openEditor(messageId){
  const idx = state.messages.findIndex(m=>m.id===messageId);
  if (idx<0) return;
  const m = state.messages[idx];
  const editorEl = document.createElement('div'); editorEl.className='editor';
  const ta = document.createElement('textarea'); ta.value = m.content;
  const saveBtn = document.createElement('button'); saveBtn.className='small-btn'; saveBtn.innerText='Update & Send';
  const cancelBtn = document.createElement('button'); cancelBtn.className='small-btn'; cancelBtn.innerText='Cancel';
  editorEl.appendChild(ta); editorEl.appendChild(saveBtn); editorEl.appendChild(cancelBtn);

  const nodes = Array.from(chatEl.children);
  const domNode = nodes[idx];
  if (!domNode) return;
  if (domNode.nextSibling && domNode.nextSibling.classList && domNode.nextSibling.classList.contains('editor')) domNode.nextSibling.remove();
  domNode.parentNode.insertBefore(editorEl, domNode.nextSibling);
  ta.focus();

  cancelBtn.addEventListener('click', ()=>{ editorEl.remove(); });
  saveBtn.addEventListener('click', async ()=> {
    const newText = ta.value.trim();
    if (!newText){ alert('Message cannot be empty'); return; }
    state.messages[idx].content = newText;
    state.messages[idx].ts = nowISO();
    saveState(); renderChat();
    editorEl.remove();
    if (m.role === 'user') {
      await sendFromIndex(idx);
    } else {
      const newUserMsg = {id:uid(), role:'user', content:newText, ts: nowISO()};
      state.messages.splice(idx+1, 0, newUserMsg);
      saveState(); renderChat();
      await sendFromIndex(idx+1);
    }
  });
}

async function resendMessage(messageId){
  const idx = state.messages.findIndex(m=>m.id===messageId);
  if (idx<0) return;
  const m = state.messages[idx];
  if (m.role === 'user') {
    await sendFromIndex(idx);
  } else {
    let prevUserIdx = -1;
    for (let i=idx-1;i>=0;i--){ if (state.messages[i].role === 'user'){ prevUserIdx = i; break; } }
    if (prevUserIdx < 0){ alert('No preceding user message to regenerate from.'); return; }
    state.messages.splice(idx,1);
    saveState(); renderChat();
    await sendFromIndex(prevUserIdx);
  }
}

/* Send logic */
async function onSend(){
  const text = userInput.value.trim();
  if (!text) return;
  const m = {id:uid(), role:'user', content:text, ts: nowISO()};
  state.messages.push(m);
  saveState();
  userInput.value = '';
  renderChat();
  await sendFromIndex(state.messages.length-1);
}

async function sendFromIndex(startIdx){
  const conv = [];
  if (settings.system_prompt) conv.push({role:'system', content: settings.system_prompt});
  for (let i=0;i<=startIdx;i++){
    const m = state.messages[i];
    if (!m) continue;
    conv.push({role:m.role, content:m.content});
  }
  if (conv.length === 0 || conv[conv.length-1].role !== 'user') {
    let lastUser = null;
    for (let i=startIdx;i>=0;i--){ if (state.messages[i].role==='user'){ lastUser = state.messages[i]; break; } }
    if (!lastUser) { alert('No user prompt to send from.'); return; }
    const conv2 = []; if (settings.system_prompt) conv2.push({role:'system', content:settings.system_prompt});
    for (let i=0;i<state.messages.indexOf(lastUser)+1;i++) conv2.push({role: state.messages[i].role, content:state.messages[i].content});
    await internalSend(conv2, state.messages.indexOf(lastUser));
    return;
  }
  await internalSend(conv, startIdx);
}

async function internalSend(conv, userIndexInState){
  const provKey = settings.provider || DEFAULT.settings.provider;
  const provider = Providers[provKey] || Providers.openai;
  const apiKey = apiKeys[provKey] || apiKeys['custom'] || '';
  if (!apiKey){ alert('No API key saved for selected provider. Save a key in Settings.'); return; }

  const placeholder = {id:uid(), role:'assistant', content:'', ts: nowISO(), streaming: true};
  const nextIdx = userIndexInState + 1;
  if (state.messages[nextIdx] && state.messages[nextIdx].role === 'assistant') {
    state.messages.splice(nextIdx, 1, placeholder);
  } else {
    state.messages.splice(nextIdx, 0, placeholder);
  }
  saveState(); renderChat();

  updateStatus('Waiting for response...', true);

  const controller = new AbortController();
  const params = { temperature: settings.temperature, top_p: settings.top_p, top_k: settings.top_k, max_tokens: settings.max_tokens };

  let accumulated = '';

  try {
    await provider.sendChat({
      messages: conv,
      model: settings.customModel || settings.model,
      params,
      streaming: settings.streaming,
      endpoint: settings.customEndpoint || undefined,
      apiKey,
      signal: controller.signal,
      onDelta: (chunk, done=false) => {
        if (chunk) accumulated += chunk;
        if (settings.show_partials || done) {
          const idx = state.messages.findIndex(m=>m.id===placeholder.id);
          if (idx>=0){
            state.messages[idx].content = accumulated;
            saveState();
            renderChat();
          }
        }
        if (done){
          const idx = state.messages.findIndex(m=>m.id===placeholder.id);
          if (idx>=0){
            state.messages[idx].streaming = false;
            state.messages[idx].ts = nowISO();
            saveState();
            renderChat();
          }
          updateStatus('Completed');
        } else {
          updateStatus('Streaming...');
        }
      }
    }).then(result => {
      if (result !== undefined && !settings.streaming) accumulated = result;
      const idx = state.messages.findIndex(m=>m.id===placeholder.id);
      if (idx>=0){
        state.messages[idx].content = accumulated;
        state.messages[idx].streaming = false;
        state.messages[idx].ts = nowISO();
        saveState(); renderChat();
      }
    }).catch((e)=>{
      const idx = state.messages.findIndex(m=>m.id===placeholder.id);
      if (idx>=0){
        state.messages[idx].error = (e && e.error) ? (typeof e.error === 'string' ? e.error : JSON.stringify(e.error)) : (e && e.message) ? e.message : 'Unknown error';
        state.messages[idx].streaming = false;
        saveState(); renderChat();
      }
      updateStatus('Error');
      console.error('API send error', e);
    });
  } catch (err) {
    const idx = state.messages.findIndex(m=>m.id===placeholder.id);
    if (idx>=0){
      state.messages[idx].error = err?.message || String(err);
      state.messages[idx].streaming = false;
      saveState(); renderChat();
    }
    updateStatus('Error');
  } finally {
    updateStatus('Idle');
  }
}

/* Update status */
function updateStatus(txt, loading=false){
  if (typeof txt === 'undefined') {
    statusEl.textContent = settings.streaming ? 'Streaming enabled' : 'No streaming';
    return;
  }
  // append streaming mode
  const mode = settings.streaming ? ' (streaming on)' : ' (streaming off)';
  statusEl.textContent = txt + (txt === 'Idle' ? '' : mode);
}

/* Import / Export */
function handleImportFile(e){
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = function(){ try{
    const j = JSON.parse(reader.result);
    if (j.messages) state.messages = j.messages;
    if (j.settings) Object.assign(settings, j.settings);
    saveState(); saveSettings();
    applySettingsToUI(); renderChat();
    alert('Import applied.');
  }catch(err){ alert('Invalid JSON'); } };
  reader.readAsText(f);
  importFileInput.value = '';
}

/* Bootstrap chat */
(function bootstrap(){
  updateStatus();
  if (!state.messages || state.messages.length === 0){
    state.messages = [{id:uid(), role:'assistant', content:'Hello — this chat runs entirely in your browser. Add an API key in Settings and send a message to start.', ts: nowISO()}];
    saveState();
  }
  renderChat();
})();

/* Initialize some UI behaviors (make tooltips accessible) */
document.querySelectorAll('.hint').forEach(el=>{
  if (!el.getAttribute('title')) {
    // provide default helpful hint if missing
    el.setAttribute('title', 'More info');
  }
});

/* Ensure sidebar initial collapsed state */
applySidebarState();

</script>
</body>
</html>
